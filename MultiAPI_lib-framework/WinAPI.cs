using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Drawing;
using System.Windows.Controls.Primitives;
using System.Windows.Controls;

/* 
  =================- INFO -===================
 * File:         | WinAPI.cs
 * Class:        | WinAPI
 * Project:      | MultiAPI
 * Author:       | Plufik
 * Version:      | 0.0.0.0
 * VerType:      | major_version.minor_version.patch_version.builds
 * Main file:    | Main.cs
 * [OPEN SOURCE] | +True
 * [CONSTRUCTOR] | -False
  =- ATTENTION -==============================
 * ATTENTION! The use of this function may cause irreversible consequences 
 * for an ordinary user in case of incorrect use or incorrectly written class code. 
 * Before publishing your software using this class, please make sure that your 
 * software will not harm the average user in any way. We are not responsible 
 * for the fact that you can harm or destroy the system with methods from the class 
 * and the like. All responsibility shifts to you. 
 * Be careful! Good luck!
 * 
 * This code was generated by AI. It is also written, added or modified by a human. 
 * The code may not work correctly in some places.
  ============================================
 */

namespace MultiAPI
{
    public static class WinAPI
    {
        public static class Window
        {
            #region Импорт методов
            [DllImport("user32.dll")]
            private static extern IntPtr CreateWindowEx(
                WindowStylesEx dwExStyle,
                string lpClassName,
                string lpWindowName,
                WindowStyles dwStyle,
                int x,
                int y,
                int nWidth,
                int nHeight,
                IntPtr hWndParent,
                IntPtr hMenu,
                IntPtr hInstance,
                IntPtr lpParam
            );

            [DllImport("user32.dll")]
            [return: MarshalAs(UnmanagedType.Bool)]
            private static extern bool ShowWindow(IntPtr hWnd, ShowWindowCommands nCmdShow);

            [DllImport("user32.dll", SetLastError = true)]
            private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

            [DllImport("user32.dll", SetLastError = true)]
            private static extern bool DestroyWindow(IntPtr hWnd);

            [DllImport("user32.dll")]
            [return: MarshalAs(UnmanagedType.Bool)]
            private static extern bool MoveWindow(IntPtr hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);

            [DllImport("user32.dll")]
            private static extern bool UpdateWindow(IntPtr hWnd);

            [DllImport("user32.dll")]
            [return: MarshalAs(UnmanagedType.Bool)]
            private static extern bool SetWindowText(IntPtr hWnd, string lpString);
            #endregion

            #region Стили
            /// <summary>
            /// Стили окна
            /// </summary>
            public enum WindowStyles : uint
            {
                WS_OVERLAPPED = 0x00000000,
                WS_CAPTION = 0x00C00000,
                WS_SYSMENU = 0x00080000,
                WS_MINIMIZEBOX = 0x00020000,
                WS_MAXIMIZEBOX = 0x00010000,
                WS_THICKFRAME = 0x00040000,
                WS_VISIBLE = 0x10000000
            }

            /// <summary>
            /// Стили окна
            /// </summary>
            public enum WindowStylesEx : uint
            {
                WS_EX_APPWINDOW = 0x00040000,
                WS_EX_WINDOWEDGE = 0x00000100
            }

            /// <summary>
            /// Тип отображения окна
            /// </summary>
            public enum ShowWindowCommands : int
            {
                SW_SHOWNORMAL = 1,
                SW_SHOWMAXIMIZED = 3
            }
            #endregion

            #region METHOD-INTPTR | Create
            /// <summary>
            /// Создать окно
            /// </summary>
            /// <param name="windowStyleEx">Стиль окна из WindowStylesEx</param>
            /// <param name="windowStyle">Стиль окна из WindowStyle</param>
            /// <param name="className">Название класса в котором будет находится окно</param>
            /// <param name="windowName">Имя окна (отображается)</param>
            /// <param name="x">Положение окна по оси X</param>
            /// <param name="y">Положение окна по оси Y</param>
            /// <param name="width">Размер окна (Ширина)</param>
            /// <param name="height">Размер окна (Высота)</param>
            /// <returns>hWindows для дальнейшего использования в методах (для переменных укажите тип IntPtr, например: IntPtr windowExample = WinAPI.CreateWindw(...); )</returns>
            public static IntPtr Create(WindowStylesEx windowStyleEx, WindowStyles windowStyle, string className, string windowName, int x, int y, int width, int height)
            {
                if (string.IsNullOrEmpty(className) || string.IsNullOrEmpty(windowName)) throw new Exception("0x00003");
                if (x < 0 || y < 0 || width < 1 || height < 1) throw new Exception("0x00006");
                return CreateWindowEx(
                    windowStyleEx,
                    className,
                    windowName,
                    windowStyle,
                    x,
                    y,
                    width,
                    height,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    IntPtr.Zero
                );
            }
            #endregion

            #region METHOD-BOOL | Show
            /// <summary>
            /// Отобразить окно
            /// </summary>
            /// <param name="hWindow">Окно</param>
            /// <param name="command">Тип отображения окна из ShowWindowCommands</param>
            /// <returns></returns>
            public static bool Show(IntPtr hWindow, ShowWindowCommands command)
            {
                return ShowWindow(hWindow, command);
            }
            #endregion

            #region METHOD-INTPTR | Find
            /// <summary>
            /// Найти окно по классу и названию
            /// </summary>
            /// <param name="className">Класс окна</param>
            /// <param name="windowName">Имя окна</param>
            /// <returns>Само окно в IntPtr для дальнейшего использования в методах или переменных</returns>
            public static IntPtr Find(string className, string windowName)
            {
                if (string.IsNullOrEmpty(className) || string.IsNullOrEmpty(windowName)) throw new Exception("0x00003");
                return FindWindow(className, windowName);
            }
            #endregion

            #region METHOD-BOOL | Destroy
            /// <summary>
            /// Уничтожение окна
            /// </summary>
            /// <param name="hWnd">Само окно</param>
            /// <returns></returns>
            public static bool Destroy(IntPtr hWnd)
            {
                return DestroyWindow(hWnd);
            }
            #endregion

            #region METHOD-BOOL | Move
            /// <summary>
            /// Изменить размер и позицию окна
            /// </summary>
            /// <param name="hWindow">Само окно</param>
            /// <param name="x">Новая позиция по оси X</param>
            /// <param name="y">Новая позиция по оси Y</param>
            /// <param name="width">Новый размер по ширине</param>
            /// <param name="height">Новый размер по высоте</param>
            /// <returns></returns>
            public static bool Move(IntPtr hWindow, int x, int y, int width, int height)
            {
                if (x < 0 || y < 0 || width < 1 || height < 1) throw new Exception("0x00006");
                return MoveWindow(hWindow, x, y, width, height, true);
            }
            #endregion

            #region METHOD-BOOL | Update
            /// <summary>
            /// Обновить окно
            /// </summary>
            /// <param name="hWindow">Само окно</param>
            /// <returns></returns>
            public static bool Update(IntPtr hWindow)
            {
                return UpdateWindow(hWindow);
            }
            #endregion

            #region METHOD-BOOL | SetText
            /// <summary>
            /// Установить новый текст (новое имя) окну
            /// </summary>
            /// <param name="hWindow">Само окно</param>
            /// <param name="text">Новый текст (Новое имя)</param>
            /// <returns></returns>
            public static bool SetText(IntPtr hWindow, string text)
            {
                if (string.IsNullOrEmpty(text)) throw new Exception("0x00003");
                return SetWindowText(hWindow, text);
            }
            #endregion
        }

        public static class ConsoleWindow
        {
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr GetConsoleWindow();

            [DllImport("user32.dll", SetLastError = true)]
            private static extern int GetWindowLong(IntPtr hWnd, int nIndex);

            [DllImport("user32.dll", SetLastError = true)]
            private static extern int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);

            private const int GWL_STYLE = -16;

            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr CreateFile(
            string lpFileName,
            int dwDesiredAccess,
            int dwShareMode,
            IntPtr lpSecurityAttributes,
            int dwCreationDisposition,
            int dwFlagsAndAttributes,
            IntPtr hTemplateFile);

            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern bool GetCurrentConsoleFont(
                IntPtr hConsoleOutput,
                bool bMaximumWindow,
                [Out][MarshalAs(UnmanagedType.LPStruct)] ConsoleFontInfo lpConsoleCurrentFont);

            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr GetStdHandle(int nStdHandle);

            [DllImport("kernel32.dll")]
            private static extern bool GetConsoleCursorInfo(IntPtr hConsoleOutput, out CONSOLE_CURSOR_INFO lpConsoleCursorInfo);

            [DllImport("kernel32.dll")]
            private static extern bool SetConsoleCursorInfo(IntPtr hConsoleOutput, ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);


            [StructLayout(LayoutKind.Explicit)]
            private struct CharInfo
            {
                [FieldOffset(0)]
                public char UnicodeChar;
                [FieldOffset(2)]
                public short Attributes;
            }

            private const int STD_OUTPUT_HANDLE = -11;

            [StructLayout(LayoutKind.Sequential)]
            private class ConsoleFontInfo
            {
                internal int nFont;
                internal Coord dwFontSize;
            }

            [StructLayout(LayoutKind.Explicit)]
            private struct Coord
            {
                [FieldOffset(0)]
                internal short X;
                [FieldOffset(2)]
                internal short Y;
            }

            [StructLayout(LayoutKind.Sequential)]
            private struct CONSOLE_CURSOR_INFO
            {
                public uint dwSize;
                public bool bVisible;
            }

            private enum ConsoleFont : int
            {
                GENERIC_READ = unchecked((int)0x80000000),
                GENERIC_WRITE = 0x40000000,
                FILE_SHARE_READ = 1,
                FILE_SHARE_WRITE = 2,
                INVALID_HANDLE_VALUE = -1,
                OPEN_EXISTING = 3
            }
            
            public enum WindowStyle : int
            {
                WS_MAXIMIZEBOX = 0x00010000,
                WS_MINIMIZEBOX = 0x00020000,
                WS_SYSMENU = 0x00080000
            }

            public static IntPtr GetWindow => GetConsoleWindow();

            public static Size GetConsoleFontSize()
            {
                IntPtr outHandle = CreateFile("CONOUT$", (int)ConsoleFont.GENERIC_READ | (int)ConsoleFont.GENERIC_WRITE,
                    (int)ConsoleFont.FILE_SHARE_READ | (int)ConsoleFont.FILE_SHARE_WRITE,
                    IntPtr.Zero,
                    (int)ConsoleFont.OPEN_EXISTING,
                    0,
                    IntPtr.Zero);
                ConsoleFontInfo cfi = new ConsoleFontInfo();
                return new Size(cfi.dwFontSize.X, cfi.dwFontSize.Y);
            }

            public static void InjectPicture(IntPtr hWnd, string pathToImage, int size_x, int size_y, int pos_x, int pos_y, bool useMetricFont = true)
            {
                using (Graphics g = Graphics.FromHwnd(hWnd))
                {
                    using (System.Drawing.Image image = System.Drawing.Image.FromFile(pathToImage))
                    {
                        if (useMetricFont)
                        {
                            Size fontSize = GetConsoleFontSize();
                            Rectangle imageRect = new Rectangle(
                                pos_x * fontSize.Width,
                                pos_y * fontSize.Height,
                                size_x * fontSize.Width,
                                size_y * fontSize.Height);
                            g.DrawImage(image, imageRect);
                        }
                        else
                        {
                            Rectangle imageRect = new Rectangle(
                                pos_x,
                                pos_y,
                                size_x,
                                size_y);
                            g.DrawImage(image, imageRect);
                        }
                    }
                }
            }

            public static void ModifyStyleControl(IntPtr hWnd, WindowStyle windowStyle) => SetWindowLong(hWnd, GWL_STYLE, GetWindowLong(hWnd, GWL_STYLE) & ~(int)windowStyle);

            public static void CursorVisibility(bool visible)
            {
                IntPtr consoleHandle = GetStdHandle(-11); // Получаем дескриптор вывода консоли (STD_OUTPUT_HANDLE)
                CONSOLE_CURSOR_INFO cursorInfo;
                GetConsoleCursorInfo(consoleHandle, out cursorInfo);
                cursorInfo.bVisible = visible;
                SetConsoleCursorInfo(consoleHandle, ref cursorInfo);
            }

            public static void ScrollVisibleFalse()
            {
                Console.BufferWidth = Console.WindowWidth;
                Console.BufferHeight = Console.WindowHeight;
            }

            public static void ScrollVisibleTrue()
            {
                Console.BufferHeight = Console.BufferHeight + 4096;
            }
        }
    }
}
